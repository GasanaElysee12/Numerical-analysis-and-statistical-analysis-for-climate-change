# -*- coding: utf-8 -*-
"""Semi-Lagrangian-4th-task.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OT9uCVaSKeqYOl9Fqs6h-MpSApfD6U4L
"""

from tqdm import tqdm
import sys

def InitCond(x):
  if x>=400. and x<500:
    return 0.1*(x-400.)
  elif x>=500. and x<=600.:
    return 20.-0.1*(x-400.)
  else:
    return 0.0

import numpy as np
import matplotlib.pyplot as plt  

class SemiLagrangian1D:
    """
    SemiLagrangian scheme for periodic 1D problems.
    """
    def __init__(self,x,y,u,dx,dt,tplot):
        """
        Initizalizes the SemiLagrangian object given initial configuration
        x    : x positions (must be equidistant)
        y    : variable at all x positions at time t
        u    : speed of advection
        dt   : time step
        tplot: time for plot
        """
        # Check dimensions
        assert x.shape[0] == y.shape[0], "x and y have different length"
        
        # check if x is equidistant
        assert x[-1] == x[0] + dx*(x.shape[0]-1), "x array not equidistant"
        # Set class variables
        self.x = x
        self.y0 = y
        self.u = u
        self.dt = dt
        self.dx = dx
        self.nplot = int(tplot/dt)

    def linear_evolve(self,nt):
        """
        Propagate the current variable using a linear interpolation
        nt : Number of time steps to be done
        """
        self.y = np.copy(self.y0)
        plt.figure( )
        plt.plot(self.x,self.y,label='initial')
        # loop through time steps
        l = 0.0
        for l in tqdm(range(1,nt+1)):
            # temporary array
            nx = self.y.shape[0]
            y_temp = np.zeros(nx)
            # loop through variable array
            for i in range(nx):
                # idx left to the departure point
                xdep = (self.x[i]-self.u*self.dt)%(self.x[-1]-self.x[0])
                if xdep < 0:
                    xdep = self.x[-1] + xdep
                j = int(np.floor(xdep/dx))
                # linear interpolation
                k = j + 1
                if k > nx-1:
                    k = 2
                alpha = (xdep-j*self.dx)/self.dx
                y_temp[i] = (1-alpha)*self.y[j] + alpha*self.y[k]
            if l%self.nplot == 0:
                plt.plot(self.x,self.y,label=r'$\phi(%s)$'%(l*dt))
            # copy array to current time
            self.y = np.copy(y_temp)
        self.decorate_and_show_plot( )
        #return current varibale
        return self.y
       
    def cubic_evolve(self,nt):
        """
        Propagates the variable using a cubic interpolation scheme.
        nt : Number of time steps to be done
        """
        # loop through time steps
        self.y = np.copy(self.y0)
        plt.figure( )
        plt.plot(self.x,self.y,label='initial')
        l = 0.0
        for l in tqdm(range(1,nt+1)):
            # temporary array
            nx = self.y.shape[0]
            y_temp = np.zeros(nx)
            # loop through variable array
            for i in range(nx):
                # idx left to the departure point
                xdep = (self.x[i]-self.u*self.dt)%(self.x[-1]-self.x[0])
                if xdep < 0:
                    xdep = self.x[-1] + xdep
                j = int(np.floor(xdep/dx))
                # linear interpolation
                k = j + 1
                if k > nx-1:
                    k = 2
                jm1 = j - 1
                if jm1 < 0:
                    jm1 = nx-2
                kp1 = k + 1
                if kp1 > nx-1:
                    kp1 = 2
                alpha = (xdep-j*self.dx)/self.dx
                y_temp[i] = -alpha * (1-alpha)*(2-alpha)/6 * self.y[jm1]
                y_temp[i] += (1-alpha**2)*(2-alpha)/2 * self.y[j]
                y_temp[i] += alpha*(1+alpha)*(2-alpha)/2 * self.y[k]
                y_temp[i] -= alpha*(1-alpha**2)/6 * self.y[kp1]
            if l%self.nplot == 0:
                plt.plot(self.x,self.y,label=r'$\phi(%s)$'%(l*dt))
            # copy array to current time
            self.y = np.copy(y_temp)
        #return current varibale
        self.decorate_and_show_plot( )
        return self.y

    def decorate_and_show_plot(self):
        plt.xlabel('Displacement in (m)')
        plt.ylabel(r'$\phi(x,t)$')
        plt.title(r'$\frac{\partial \phi}{\partial t}-u \frac{\partial \phi}{\partial x}=0$')
        plt.legend()
        plt.grid('on')
        plt.show()
       
#Define the constants

dx = 0.5
dt = 1.0
tp = 500.0
u = 0.75 #Speed

final_time = 2000.0

x = np.arange(0.0,1000.+dx,dx)
y = np.array(list(map(InitCond,x))) #Assign the initial condition values

pred = SemiLagrangian1D(x,y,u,dx,dt,tp)#Instatiation
lstatus = pred.linear_evolve(int(final_time/dt)) # Call linear interpolation
cstatus = pred.cubic_evolve(int(final_time/dt))  # Call cubic interpolation
